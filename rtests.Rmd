```{r test matrix generation}

oldest_migration_matrix <- function(num_populations){
  oldest_matrix <- paste("//Migration matrix", num_populations - 1)
  temp <- matrix(rep("0", num_populations^2), ncol = num_populations)
  oldest_matrix <- c(oldest_matrix, apply(temp, 1, paste, collapse = " "))
  return(oldest_matrix)
}

current_migration_matrix <- function(num_populations, ...){
  current_matrix <- 
    c("//Migration matrix 0")
  for(i in 1:num_populations){
    matrix_row <- c()
    for(j in 1:num_populations){
      if(i == j) mij <- "0"
      else{
        from <- population_name(index = j-1, ...)
        to <- population_name(index = i-1, ...)
        mij <- paste("MIG_", from, "to", to, sep = "")
      }
      matrix_row <- c(matrix_row, mij)
    }
    current_matrix <- c(current_matrix, paste(matrix_row, collapse = " "))
  }
  return(current_matrix)
}

matrix_generation <- function(num_pops, divergence_events, ...){
  subsequent_matrix <- current_migration_matrix(num_populations = num_pops, ...)
  output <- subsequent_matrix
  # Loop through all the divbergence events to create matrices going backward in time
  for(i in rev(seq_along(divergence_events))){
    event <- divergence_events[i]
    subsequent_matrix_index <- gsub("T.* ([0-9])$", "\\1", event)
    if(subsequent_matrix_index == (num_pops - 1) ) subsequent_matrix <- oldest_migration_matrix(num_pops)
    else{ 
      coalescing_population <- gsub("^TDIV_[a-zA-Z]*to([a-zA-Z]*) [0-9].*$", "\\1", event)
      subsequent_matrix <- 
        gsub(
          paste0("MIG_", coalescing_population, "to[A-Z]*|", "MIG_[A-Z]*to", coalescing_population), 
          "0", 
          subsequent_matrix[-1]
        )
      subsequent_matrix <- 
        c(
          paste("//Migration matrix", subsequent_matrix_index), 
          subsequent_matrix
        )
    }
    output <- c(output, subsequent_matrix)
  }
  return(output)
}

population_name <- function(index) {
    if (index == 0) {
        return("RAYA")
    }
    else {
        return("TREVOR")
    }
}

output <- matrix_generation()
```

```{r randomize divergence order}
my_sample <- function(x, ...){
  if(length(x) == 1) return(x)
  else sample(x, ...)
}

possible_roots = c(1,5,6,7,9)
root <- my_sample(possible_roots, size = 1)
root
class(root)

# root2 <- sample(possible_roots, 1)
# root2
```

```{r seq along}
populations<-c("SF", "WRM", "VAL")
# index<-seq_along(populations) - 1
index<-1
output<-populations[index + 1]
print(is.character(output))
```

```{r trying again}
population_name <- function(index = NULL, split_SF, ghost_present){
  if(!split_SF){
    populations <- c("SF", "WRM")
  } else populations <- c("SFWC", "SFP", "WRM")
  if(ghost_present) populations <- c(populations, "G")
  if(is.null(index)) index <- seq_along(populations) - 1
  return(populations[index + 1])
}

my_sample <- function(x, ...){
  if(length(x) == 1) return(x)
  else sample(x, ...)
}

randomize_divergence_order <- function(...){
  migrants <- 1 
  growth_rate <- 0 # set to 0 because it's like that in all the example templates
  output <- c()
  possible_roots <- c(2)
  possible_leaves <- c(0,1)
  rev_migration_matrix_index <- length(possible_leaves)
  while(length(possible_leaves) > 0){
    root <- my_sample(possible_roots, size = 1) 
    offshoot <- my_sample(possible_leaves, size = 1)
    print(cat("offshot: ", offshoot, "length: ", length(offshoot)))
    root_name <- population_name(index = root, ...)
    offshoot_name <- population_name(index = offshoot, ...)
    print(cat("offshoot name: ", offshoot_name))
    time <- paste0("TDIV_", root_name, "to", offshoot_name)
    new_deme_size <- paste0("RES_", root_name, "to", offshoot_name)
    output <- 
      c(output, 
        paste(
          time, 
          offshoot, 
          root, 
          migrants, 
          new_deme_size, 
          growth_rate, rev_migration_matrix_index, 
          collapse = " "
        )
      )
    possible_roots <- c(possible_roots, offshoot)
    possible_leaves <- setdiff(possible_leaves, offshoot)
    rev_migration_matrix_index <- rev_migration_matrix_index - 1
  }
  return(output)
}
randomize_divergence_order(split_SF=FALSE, ghost_present=FALSE)
```

```{r pop names}
population_name <- function(index = NULL, split_SF, ghost_present){
  if(!split_SF){
    populations <- c("SF", "WRM")
  } else populations <- c("SFWC", "SFP", "WRM")
  if(ghost_present) populations <- c(populations, "G")
  if(is.null(index)) index <- seq_along(populations) - 1
  return(populations[index + 1])
}
output = population_name(index=NULL, TRUE, FALSE)
print(is.character(output))
print(length(output))
print("done")
```
```{r mig info}
mig_mat <- c(0,0,0)
divergence_events<-c("TDIV_['WRM']to['SFP'] 1 2 1 RES_['WRM']to['SFP'] 0 2", "TDIV_['WRM']to['SFWC'] 0 2 1 RES_['WRM']to['SFWC'] 0 1")
mig_info <- c(as.character(length(divergence_events) + 1), mig_mat)
mig_info
```